1.已经实现的功能列表：
1）发现他的邻接点，并知道其端口和链路成本。
2）构造一个分组，分组中包含它的链路状态。
3)  将这个分组发送给其他的路由器。
4)  收到分组后，检查如果是重复分组则丢弃，否则转发给除了源以外的路由器
5)  计算出到每一个其他路由器的最短路径。例如，每个路由器运行Dijkstra算法就可以找从它到每一个其他路由器的最短路径。
6)  经过一段时间没接到邻接点的信息，就判定该链路故障。并发送给其他路由器。
2.用于网络拓扑的数据结构：
邻接表：edgeList存放每个节点和邻接点的成本信息
edgeList是字典类型，每一个edgeList[u]存放了一个列表，其中包含了邻接点u之间的成本。
edgeList[u]=[(v1,c1),(v2,c2)……]
其中v1,v2分别表示临界点，c1,c2分别表示成本。
3．链路状态数据包格式的数据结构：
该路由器的名字u+edgeList[u]
如何处理节点故障？
每个活跃的路由器都会定时给邻近的节点发送心跳报文。当某路由器连续一段时间没收到某相邻路由器的心跳报文时，判定两者之间的链路失效，产生新的报文发送给相邻路由器，并更新本地网络拓扑。
如何避免过多链路状态的广播？
	路由器收到链路状态报文后只会转发给除源以外的路由器。
	每个收到的报文都保存在列表里，如果报文重复，则直接丢弃不广播。
3.
一些trade-off
	采用邻接表的数据结构，查找时需要变例，但是比较省空间。
可能的改进和拓展
	可以加功能：当新加入节点时或者成本变化时更改链路状态并发送给邻居。
	每个报文编码一段序列号，序列号重复则直接丢弃，不用比较整篇报文。

4.udp编程参考
#不需要建立连接
import socket
#创建socket对象
#SOCK_DGRAM  udp模式
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
#发送数据 字节
s.sendto("你好".encode(),("169.254.184.146",8000))
 
import socket
#创建socket对象
#SOCK_DGRAM  udp模式
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
s.bind(("169.254.184.146",8000)) #绑定服务器的ip和端口
data=s.recv(1024) #一次接收1024字节
print(data.decode())# decode()解码收到的字节
参考网址https://www.jb51.net/article/165933.htm
